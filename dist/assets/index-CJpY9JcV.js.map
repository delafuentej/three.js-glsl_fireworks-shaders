{"version":3,"file":"index-CJpY9JcV.js","sources":["../../src/shaders/firework/vertex.glsl","../../src/shaders/firework/fragment.glsl","../../src/script.js"],"sourcesContent":["uniform float uSize;\nuniform vec2 uResolution;\nuniform float uProgress;\n\nattribute float aSize;\nattribute float aTimeMultiplier;\n\n#include ../includes/remap.glsl\n\nvoid main(){\n    //creation a new progress\n    float progress = uProgress * aTimeMultiplier;\n    // update the position of the particles: newPosition \n    vec3 newPosition = position;\n\n     //REMAP uProgress: \n     //1. EXPLODING Phase: between 0.0 and 0.1\n     //float explodingProgress = remap(uProgress, 0.0, 0.1, 0.0, 1.0);\n     float explodingProgress = remap(progress, 0.0, 0.1, 0.0, 1.0);\n     //we need to clamp the value right after the remap:(containment after particle explosion)\n     explodingProgress = clamp(explodingProgress, 0.0, 1.0);\n     //to speed up the animation at the beginning and to slow down before reaching the end of transition: 1- pow(1-x)\n     explodingProgress = 1.0 - pow( 1.0 - explodingProgress, 3.0);\n     // we need to move the particles using explodingProgress:\n     newPosition *= explodingProgress;\n\n    //2. FALLING Phase: \n    //float fallingProgress = remap(uProgress, 0.1, 1.0, 0.0, 1.0);\n     float fallingProgress = remap(progress, 0.1, 1.0, 0.0, 1.0);\n    fallingProgress = clamp(fallingProgress, 0.0, 1.0);\n    //to fall down fast and slow down\n    fallingProgress = 1.0 - pow( 1.0 - fallingProgress, 3.0);\n    newPosition.y -= fallingProgress * 0.2;\n\n    //3. SCALING Phase: \n    //float sizeOpeningProgress = remap(uProgress, 0.0, 0.125, 0.0, 1.0);\n     float sizeOpeningProgress = remap(progress, 0.0, 0.125, 0.0, 1.0);\n   // float sizeClosingProgress = remap(uProgress, 0.125, 1.0, 1.0, 0.0);\n    float sizeClosingProgress = remap(progress, 0.125, 1.0, 1.0, 0.0);\n    // to get the min of the two values\n    float sizeProgress = min(sizeOpeningProgress, sizeClosingProgress);\n    // to clamp sizeProgress between 0 ans 1\n    sizeProgress = clamp(sizeProgress, 0.0, 1.0);\n\n    //4. TWINKLING Phase:\n   //float twinklingProgress = remap(uProgress, 0.2, 0.8, 0.0, 1.0);\n     float twinklingProgress = remap(progress, 0.2, 0.8, 0.0, 1.0);\n    twinklingProgress = clamp(twinklingProgress, 0.0, 1.0);\n    //put the twinklingProgress aside a try to make the particles twingle  all the time\n    // to become a value from  0 to 1 => * 0.5 + 0.5\n   // float sizeTwinkling = sin(uProgress * 30.0)  * 0.5 + 0.5;\n     float sizeTwinkling = sin(progress * 30.0)  * 0.5 + 0.5;\n    //Combination the twinklingProgress with the sizeTwinkling\n     sizeTwinkling = 1.0 - sizeTwinkling * twinklingProgress;\n\n\n    vec4 modelPosition = modelMatrix * vec4(newPosition, 1.0);\n\n   //we want the particles to twinkle a little after the particles start to scale down=>\n   //the particles scale up and down quite fast\n   // as if the fire burning them was fading out uncontrollably\n\n\n\n    //vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n \n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectedPosition = projectionMatrix * viewPosition;\n\n    //Final Position\n    gl_Position = projectedPosition;\n\n    //Final Size\n    //  uResolution.y because the field of view is vertical,  not horizontal (most cases)\n    gl_PointSize = uSize * uResolution.y * aSize * sizeProgress * sizeTwinkling;\n    // adding perspective to the particles:\n    gl_PointSize *= 1.0 / - viewPosition.z;\n\n    if(gl_PointSize < 1.0) gl_Position = vec4(9999.9);\n}","uniform sampler2D uTexture;\nuniform vec3 uColor;\n\nvoid main(){\n    // to extract the color as vec4 textureColor from uTexture using texture() function;\n    // as the texture is upside down we can play with gl_PointCoort but we are going to flip the texture in script.js\n    // this textures are gray scale textures => we do not need the whole vec4(rgba)\n    //vec4 textureColor = texture(uTexture, gl_PointCoord);\n    //float textureAlpha = texture(1.0, 1.0, 1.0, gl_PointCoord).r;\n    //Aplying uTexture:\n     float textureAlpha = texture(uTexture, gl_PointCoord).r;\n    \n\n    //Final Color\n   // gl_FragColor = textureColor;\n   gl_FragColor = vec4(uColor, textureAlpha);\n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}","import * as THREE from 'three';\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\nimport { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';\nimport { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';\nimport GUI from 'lil-gui';\nimport gsap  from 'gsap';\nimport fireworkVertexShader from './shaders/firework/vertex.glsl';\nimport fireworkFragmentShader from './shaders/firework/fragment.glsl';\n\n/* We are going to use particles and animate them in a single vertex shader(for performance reason)\n-the same code will be executed for all particles:\n     - They start to expand fast in every direction\n     - They scale up even faster\n     - They start to fall down slowly\n     - They scale down\n     - They twinkle as they disappear   \n     - All the animation steps are interwined -remap the progress\n\n     1.FIREWORKS. \n     - We muss create a function to create fireworks => createFireworks() => because we want to create it when we click\n     - function's parameters: position, radius, amount of particles(count), color, etc\n     - Inside that function(createFireworks) we are going to create: geometry, material, points\n     - we are going to start from a empty geometry (BufferGeometra) and fill it with random positions\n     - Geometry: the geometry is empty we need to fill it with position through attributes.\n     - Material: we initially use PointsMaterial to initially see something which we will then replace by ShaderMaterial\n     - Change the position of the firework according to a position parameter => firework.position.capy(position) to control the positon\n     - Create the custom shader: shaders/firework/vertex.glsl & shaders/firework/fragment.glsl & import them into the file script.js\n\n     2. PERSPECTIVE:\n     - To add perspective to the particles, we need to multiply gl_PointSize by 1.0/ - viewPosition.z\n     - Uniforms (uSize) to control the size of the particles => sent it to the js file script to the shaders, and add the size parameter into\n      createFireworks function.\n      3.PROPORTIONATE TO THE RENDER HEIGHT;\n      - To fixed 2 issues: A. the pixel ratio & B.the size relative to the render height\n      - B.the size relative to the render height: Resize the window vertically and check how the particles behave => Test:\n      - We i resize the viewport the plane test get smaller/bigger:  the plane size is proportional to the height of the renderer\n      - but when we have particles that they don't behave like that: the particles don't get smaller/bigger\n      - Uniforms (uResolution): To fix the issue B. we need to send the whole resolution of the renderer to the shader: uResolution: new THREE.Uniform(new THREE.Vector2(sizes.width, sizes.height))\n        - in the resize callback function we want to update uResolution but we do not have access to the material & cannot creat it outside of the function createFirework()\n        - to solve that we have to create the Vector2(sizes.width, sizes.height) outside the function sizes.resolution = new THREE.Vector2() and send into uSize,  and than update it in the resize callback function\n     - A. Pixel Ratio issue: we have to include the pixel ration in sizes object to be abble to handle it\n       - then we have to update it in the callback function resize & update too the renderer ( renderer.setPixelRatio(sizes.pixelRatio);)\n       - when instantiating and updating sizes.resolution, we have to multiply sizes.width & sizes.height by sizes.pixelRatio\n    3.TEXTURE(/static/particles folder) => uniforms:  uTexture\n        - We do not access the texture coordinates the same way when it comes to particles & despite we use gl_PointCoord, but we need uV coordinates\n        to pick the rigth pixel from the texture. We cannot use the uv attribute because it is inside the particle\n \n    4. RANDOM SIZE \n        - Perfect particles do not exists and would look unrealistic, we are going despite to use an attribute => sizesArray <=> aSize attribute & \n        in vertex.glsl retrieve the aSize attribute and multiply th gl_PointSize\n    \n    5. SPHERE DISTRIBUTION:\n        - We want to position the particles on a sphere (instead on a cube)=> we have to use three.js class Spherical\n        - First we need to add a new parameter into the function createFirework: radius parameter\n        - Create const spherical and convert it to a 3D position by creating a position from a Vector3\n    6.COLOR:\n        - Adding color parameter into createFirework function\n        - Adding uColor uniform , send it the color parameter\n        - Aplying the uniform vec3 uColor in the file fragment.glsl\n    7.PROGRESS:(uniforms uProgress)\n        - To be able to control the animation we need a value that changes from 0 to 1\n        - We are going to use that uniuqe value in the vertex shader to contron  all the aspects of the animation\n        - To animate uProgress we are going to use \"gsap\"\n        - DISPOSE OF OBJECTS(destroy function): When the animation ends, the particles of the fireworks should not be visible\n        and we can get rid of it properly\n        - REGENERATE THE FIREWORKS WITH A CLICK: addEventListener function\n    8. ANIMATION: \n        - The animation is composed of 5 diffetent phases\n            a) The particles start to expand fast in every direction (exploding)\n            b) They scale up even faster (scaling)\n            c) They start to fall down slowly (falling)\n            d) They scale down\n            e) They twinkle as they dissapear (twinking)\n        - We have to separete these phases and remap the progrees to suit the phase we are dealing with (vertex.glsl)\n        - We need to update the position of the particles an attribute: vec3 newPosition = positon\n        - All particles follow a similar animaion at the exact same time => We must make that their life span\n        should be different: creation a timeMultiplier as an attribute and make the particles randomly faster\n        - With the aTimeMultiplier attribute in vertex.glsl we create a new progress. \n\n\n\n\n*/  \n/**\n * Base\n */\n// Debug\n//const gui = new GUI({ width: 340 });\n\n// Canvas\nconst canvas = document.querySelector('canvas.webgl');\n\n// Scene\nconst scene = new THREE.Scene();\n\n// Loaders\nconst textureLoader = new THREE.TextureLoader();\nconst exrLoader = new EXRLoader();\n\n\n\n\n/**\n * Sizes\n */\nconst sizes = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n    pixelRatio: Math.min(window.devicePixelRatio, 2)\n};\n\n//sizes.resolution = new THREE.Vector2(sizes.width, sizes.height);\nsizes.resolution = new THREE.Vector2(sizes.width * sizes.pixelRatio, sizes.height * sizes.pixelRatio);\n\n// callback funcion resize\nwindow.addEventListener('resize', () =>\n{\n    // Update sizes\n    sizes.width = window.innerWidth;\n    sizes.height = window.innerHeight;\n    sizes.pixelRatio = Math.min(window.devicePixelRatio, 2);\n    sizes.resolution.set(sizes.width, sizes.height);\n\n    // Update camera\n    camera.aspect = sizes.width / sizes.height;\n    camera.updateProjectionMatrix();\n\n    // Update renderer\n    renderer.setSize(sizes.width, sizes.height);\n    renderer.setPixelRatio(sizes.pixelRatio);\n});\n\n/**\n * Camera\n */\n// Base camera\nconst camera = new THREE.PerspectiveCamera(25, sizes.width / sizes.height, 0.1, 100);\ncamera.position.set(1.5, 0, 6);\nscene.add(camera);\n\n// Controls\nconst controls = new OrbitControls(camera, canvas);\ncontrols.enableDamping = true;\n\n/**\n * Renderer\n */\nconst renderer = new THREE.WebGLRenderer({\n    canvas: canvas,\n    antialias: true\n});\nrenderer.setSize(sizes.width, sizes.height);\nrenderer.setPixelRatio(sizes.pixelRatio);\n\n/**\n * Environment map\n */\n\n\nconst loadEnvironmentMap = async () => {\n    try {\n        const environmentMap = await new Promise((resolve, reject) => {\n            exrLoader.load(\n                './environmentMap/night_countryside.exr',//.exr\n                resolve,\n                undefined,\n                reject\n            );\n        });\n\n        environmentMap.mapping = THREE.EquirectangularReflectionMapping;\n        \n        \n        scene.environment = environmentMap;\n        scene.background = environmentMap;\n\n    } catch (error) {\n        console.error('Error loading environment map:', error);\n    }\n};\n\nloadEnvironmentMap();\n\n/**\n * Fireworks\n */\n\n//Textures\n    const textures = [\n        textureLoader.load('./particles/1.png'),\n        textureLoader.load('./particles/2.png'),\n        textureLoader.load('./particles/3.png'),\n        textureLoader.load('./particles/4.png'),\n        textureLoader.load('./particles/5.png'),\n        textureLoader.load('./particles/6.png'),\n        textureLoader.load('./particles/7.png'),\n        textureLoader.load('./particles/8.png')\n    ];\n\n\n\nconst createFirework = (count, position, size, texture, radius, color) => {\n\n    // we have three values per vertex: despite * 3\n    const positionsArray = new Float32Array(count * 3);\n    //we need only one value per vertex:\n    const sizesArray = new Float32Array(count);\n    // timeMultipliersArray of count length and fill it  with values going radomly from 1-2\n    const timeMultipliersArray = new Float32Array(count);\n    // to fill this array:\n    for(let i = 0; i < count; i++){\n\n        //i3 ist values goes 3*3 <=> to fill the positionsArray 3*3\n        const i3 = i * 3;\n\n        //SPHERICAL (one spherical value per vertex- despite inside the loop)\n        const spherical = new THREE.Spherical(\n            radius * (0.75 + Math.random() * 0.25),\n            Math.random() * Math.PI,//\"phi\" angle= half circle \"from bottom to up\"\n            Math.random() * Math.PI * 2 // \"theta\" angle \"\"\n        );\n        const position = new THREE.Vector3();\n        // convertion the spherical coordinates to a 3D position: \n        position.setFromSpherical(spherical);\n\n\n\n        //positions: (Math.random goes from 0 to 1, we apply -0.5 to centered in the scene)\n        positionsArray[i3 + 0] =  position.x;//Math.random() - 0.5;//x\n        positionsArray[i3 + 1] = position.y; //Math.random() - 0.5;//y\n        positionsArray[i3 + 2] = position.z; //Math.random() - 0.5;//z\n\n        //sizes:\n        sizesArray[i] = Math.random();\n\n        //timeMultiplier=>a randomly value between 1 and 2:  potentially faster\n        timeMultipliersArray[i] = 1 + Math.random();\n        \n    } \n    //Geometry\n    const geometry = new THREE.BufferGeometry();\n    // the geometry is empty we need to fill it with position through attributes:\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsArray, 3));\n    geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizesArray, 1));\n    geometry.setAttribute('aTimeMultiplier',  new THREE.Float32BufferAttribute(timeMultipliersArray, 1));\n    // We have to flip the texture to become the right direction\n    texture.flipY = false;\n    //Material\n    const material = new THREE.ShaderMaterial({\n        vertexShader: fireworkVertexShader,\n        fragmentShader: fireworkFragmentShader,\n        uniforms: {\n            uSize: new THREE.Uniform(size),\n           // uResolution: new THREE.Uniform(new THREE.Vector2(sizes.width, sizes.height))\n            uResolution: new THREE.Uniform(sizes.resolution),\n            uTexture: new THREE.Uniform(texture),\n            uColor: new THREE.Uniform(color),\n            uProgress: new THREE.Uniform(0)\n        },\n        transparent: true,\n        depthWrite: false,\n        blending: THREE.AdditiveBlending\n    });\n\n    // to create the points:\n    const fireworks = new THREE.Points(geometry, material);\n    fireworks.position.copy(position);// to copy the value from the position parameters\n    scene.add(fireworks);\n\n    const destroy = () => {\n        scene.remove(fireworks);\n        geometry.dispose();\n        material.dispose();\n        console.log('destroy');\n    }\n    //Animation with gsap\n    gsap.to(\n        material.uniforms.uProgress,\n        { \n            value: 1, \n            duration: 3,\n            ease: 'linear',\n            onComplete: destroy\n        },\n    )\n\n\n\n\n}\n\n/**\n * Firework Sound\n */\nconst fireworkSound = new Audio('./sounds/fireworks_sound.wav');\n\nconst playFireworkSound = () => {\n    fireworkSound.currentTime = 0; // Reiniciar sonido si ya se está reproduciendo\n    fireworkSound.play().catch(error => console.error(\"Error al reproducir el sonido:\", error));\n}\n\n/**\n * CreateRandomFirework function\n */\n\nconst createRandomFirework = () => {\n    const count = Math.round(400 + Math.random() * 1000);\n    const position = new THREE.Vector3(\n        (Math.random() - 0.5) * 2,\n        Math.random(),\n        (Math.random() - 0.5) * 2\n    ); \n    const size = 0.1 + Math.random() * 0.1;\n    const texture = textures[Math.floor(Math.random() * textures.length)];\n    const radius = 0.5 + Math.random();\n    const color = new THREE.Color();\n    color.setHSL(Math.random(), 1, 0.5 + Math.random() * 0.3);\n    // const color = new THREE.Color();\n    // color.setHex(0xffffff * Math.random()); \n//  const palette = [\"#e63946\", \"#f4a261\", \"#2a9d8f\", \"#264653\", \"#8ab17d\"];\n// const color = new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);\n    createFirework(count, position, size, texture, radius, color);\n}\n\nconst handleFireworkClick = () => {\n    playFireworkSound();\n    createRandomFirework();\n}\n\n /**\n * Regenerate the Fireworks\n */\nwindow.addEventListener('click',handleFireworkClick);\n/**\n * Test\n */\n// const test = new THREE.Mesh(\n//     new THREE.PlaneGeometry(),\n//     new THREE.MeshBasicMaterial()\n// );\n// scene.add(test);\n\n/**\n * Animate\n */\nconst tick = () =>\n{\n    // Update controls\n    controls.update()\n\n    // Render\n    renderer.render(scene, camera)\n\n    // Call tick again on the next frame\n    window.requestAnimationFrame(tick)\n};\n\ntick();"],"names":["vertex_default","fragment_default","canvas","scene","THREE.Scene","textureLoader","THREE.TextureLoader","exrLoader","EXRLoader","sizes","THREE.Vector2","camera","renderer","THREE.PerspectiveCamera","controls","OrbitControls","THREE.WebGLRenderer","loadEnvironmentMap","environmentMap","resolve","reject","THREE.EquirectangularReflectionMapping","error","textures","createFirework","count","position","size","texture","radius","color","positionsArray","sizesArray","timeMultipliersArray","i","i3","spherical","THREE.Spherical","THREE.Vector3","geometry","THREE.BufferGeometry","THREE.Float32BufferAttribute","material","THREE.ShaderMaterial","fireworkVertexShader","fireworkFragmentShader","THREE.Uniform","THREE.AdditiveBlending","fireworks","THREE.Points","destroy","gsap","fireworkSound","playFireworkSound","createRandomFirework","THREE.Color","handleFireworkClick","tick"],"mappings":"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"}